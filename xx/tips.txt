思路：对输入排序。

错误：scanf没有用&取地址。

可以考虑在输入时过滤确实不合格的数据项。

不要惧怕每次循环都要O(N)会超时，先把程序跑起来。


输出格式注意，is, are和名词单复数：
```cpp
if (N == 1)
    printf("There is %d account and no account is modified\n", N);
else
    printf("There are %d accounts and no account is modified\n", N);
```


如果name不超过10个字符，那么如果要自己用char[]数组存储的话，记得分派至少11字节内存空间，多一个字节，这样才能存储'\0'。


在循环中频繁刷新缓冲区，如`cout << endl;`，是造成超时的一个重要原因。


```cpp
// 注意如果有一下两种输入的区别，对于"Is PAT&TAP symmetric?"，
// 下面第一种s的值是"Is"，第二种的值是"Is PAT&TAP symmetric?"。
// cin >> s;
getline(cin, s);
```


多个容器，每个容器存放一个类别的数据。


void dfs(int v, int level) {
	visited[v] = true;
	for (int x: m[x]) {
		if (!visited[x])
			// dfs(x, level++); // 错误。
			dfs(x, level+1);
	}
}


```cpp
min_ = INT_MAX;
// do something ...
if (min_ = INT_MAX)
	return;
	
// 最好写成，
if (INT_MAX == min_)
	return
```


把代码从codeblock复制到网页后，记得检查头文件，如codeblock会默认帮你包含<string>, <climits>等。


注意仔细看题，理解题意，不要一上来连题意都不理解就马上码代码。


注意一个点，很容易忽视：
```cpp
#include <iostream>
using namespace std;

int main(int argc, char**argv) {
    int x = 1;
    printf("%f\n", x);
    printf("%f\n", (float)x);

    // 0.000000
    // 1.000000
}
```


注意，不要看到样例输入的是一位数，就可以用`u[1]-'0'`或`u[0]-'0'`这种写法转换成数字，要知道这是样例，测试可能有多位数，所以还是用string存储，然后用string::stoi()进行转换。


bfs, dfs
if (!visited[i] && e[x][i]) { // 注意还要判断有边相连才能将相邻的结点入队。


```cpp
#include <iostream>
#include <string>
using namespace std;

int main(int argc, char**argv) {
    // ./a.out < f
    // f的内容如下：
    // 3
    // abc
    string s;
    int x;
    // cin >> x; // 3
    // scanf("%d", &x); // 3
    scanf("%d\n", &x); // 3 abc
    getline(cin, s);
    cout << x << '\t' << s << endl;
    // 所以就是，记得吃掉换行符。
}
```

有空格/空白符，用getline。

返回值类型不要写错了，是float若写成int，会导致数据失效。

float精度不足也可能导致测试失败，考虑double。

isPrime()，<是错误的，要`<=sqrt`。

```cpp
#include <iostream>
#include <climits>
using namespace std;

int main(int argc, char**argv) {
    int x = INT_MAX, y = INT_MAX;
    long long z;
    z = x+y;
    cout << z << '\n'; // -2
    z = (long long)x+y;
    cout << z << '\n'; // 4294967294
    z = static_cast<long long>(x)+y;
    cout << z << '\n'; // 4294967294
    // 所以，要使运算不溢出，除了用更大的类型存储外，重要的还要告诉编译器做更大类型的运算，否则做的是int类型的运算，还是会溢出。
    // 或者从一开始，就都用比较大的类型存储。
    //
    // 另外还注意，操作数的顺序也有关系：
    double d = 3.14;
    x = 3;
    cout << d*x*y << '\n'; // 2.02293e+10
    cout << x*d*y << '\n'; // 2.02293e+10，前面进行的是浮点型运算，没有溢出，再与另一个整型做浮点型运算，还是没有溢出，因为double能够表示的数的范围比int大很多。
    cout << x*y*d << '\n'; // 6.7431e+09，前面两个整型做整型运算，结果溢出了，然后再与浮点型运算。
}
```


测试过不了，也有可能是类型的大小不足以存储结果，比如两个int/float相乘/相加，可能溢出。


别忘了设置递归终点。

测试算法对边界是否正常工作，最简单的如输入的数据的上界和下界，如-1000, 1000, 0等。


注意不要看到测试样例的数字都是一位数，就用字符来存储，然后`c[i]-'0'`转换为整型，这是不对的，应该用string存储，然后用stoi, stof等，这也才能应对多位数的情况。

没有思路，要不先对输入的非有序序列排一下序试试，再观察一下。


在多次查询中，在某次查询时，即使只接收了一点输入就可以得出结果，也要把剩下的输入接收完，不然下一次查询就会读到上一次查询的未接收的数据。

注意，可能数组越界，应该crash，测试结果却显式结果错误。

要注意输入的图不连通/有多个连通分量的情况。

使用并查集时，写完make_set()，在main()中马上调用，不然很容易忘。

多次查询，记得清空容器以及重新初始化一些变量，避免影响下次查询。

注意关注题目给出的数据的范围，如果数据量比较小，就大胆去写，多层循环也没关系。

为了避免遍历，而需要O(1)/O(logn)存取，则可以用一个数组/map/set。

遍历树的先序序列，相当于先序遍历树。遍历中序序列和后序序列同理，这是一个很重要又容易忽略的想法。

思维惯性，有序 ==》二分查找，n =》logn。

使用并查集时，写完make_set()，在main()中马上调用，不然很容易忘。

一串连续的数字只需要存储起点和长度即可，不需要用容器存储每一个数。

实在没有思路时，尝试暴力破解或枚举，总比空着好。而且题目中给出的数据量不大，就是在提示我们没有思路时试试暴力枚举。

如果只需要哈希，不需要有序，可用unordered_map, unordered_set，而不用map, set。

如果输入string，用cin，不能用scanf()。

抹去低位、留下高位，一般想到除法或右移；抹掉高位、留下低位，一般考虑模运算或左移。

每次都取模，防止溢出，而不是最后才取模，可能中间就溢出了。

没有思路，要不先对输入的非有序序列排一下序试试，再观察一下。

局部变量没有默认初始化，记得显式初始化，特别是计数器一类的变量。

对于多轮查询，即使提前知道了答案，也要把当前的输入读完。

递归中逐步构造序列时，可以用“在相同位置覆盖”代替“插入后删除恢复”，但并非必要，因为vector的push_back()和pop_back()的时间复杂度是O(1)。

递归调用并不是并行执行的，而是串行执行的。

当表格的利用率很低的时候，就没必要提前打表了。

大于其左边所有的元素==大于其左边最大的元素，小于其右边所有的元素==小于其右边最小的元素。

resize()后用[]而不用push_back()。

if(!【这里写入期望为0或false的表达式】)。

bfs时，在结点入队时更新相关数据，和在结点出队时才更新相关数据的区别。

提交前检查：
1. 检查头文件是否包含。
2. 检查变量是否正确声明，类型是否正确，不要期望float而声明为int。
3. 检查打印格式是否符合题意要求，如最少5位数，小数点精确到2位，-1不用补0，尾部不要有空格等。
4. 注意inventory可能是小数，这是因为inventory的单位是千吨，而不是一个月饼！
5. 提交前记得把用来调试的多余的打印语句删掉。


std::map，如果只是想直到某个pair是否存在的话，不能用`map[key]`，因为这样不存在会默认创建。应该用find或count。

双指针，使用同一个数组插入，由于消耗比插入快，所以可以保证不会覆盖未被使用到的信息。

1. 用邻接表存储图时的dfs：
    for (int x: graph[v]) {
        if (!visited[x])
            dfs(x);
    }
2. 用邻接矩阵存储图时的dfs：
	for (int i=1; i<=N; i++) {
		if (!visited[i] && graph[i][v]) // XXX 注意只有相连才继续往下遍历，这点容易忽略。
			dfs(i);
	}
	
有边相连很重要，无边相连的话，逻辑上来说，两个互不相关的顶点，没有任何需要/可以处理的。

用被删除顶点连接的顶点的度是否为1，来判断有几个连通分量是错误的，考虑四个连通分量，它们的大小都大于一个顶点，然后这四个连通分量依赖这个被删除顶点与其它三个连通分量相连的情况。

minNeed是主要标准，minBack是次要标准，当主要标准更新后，次要标准无论是否比之前好，都要更新。

for (int x: pre[v]) { // 递归调用并不是并行展开的，而是串行展开的，一个完全展开后，返回到这里，再展开另一个分支。
	// if (!visited[x])
		dfs(x);
}


不要看到样例输入的是一位数，就可以用`u[1]-'0'`或`u[0]-'0'`这种写法转换成数字，要知道这是样例，测试可能有多位数，所以还是用string存储，然后用string::stoi()进行转换。

printf("G%d\n%.1f %.1f\n", res-N, (float)maxMin_, minSum*1.0/N); // 注意将整型转换为浮点型，还有*1.0做浮点数除法。
如果没有强制转换成浮点型，那么打印的结果就会出错。

注意还要判断有边相连才能将相邻的结点入队。


City citys[200]; // 真正的信息存储。
int edge[200][200];
map<string, int> idx; // 编码时普遍使用下标/索引/指针，这里建立从City对象的name属性到该City对象在数组中的索引/下标/指针的映射。


3. XXX 一个数N的K-P序列可能有多个，题目要求选择其中最大的序列，最大的意思是：sequence {a1, a2, ……, aK} is said to be larger than {b1, b2, ……, bK} if there exists 1≤L≤K such that ai=bi for i<L and aL>bL. 通过dfs是从最大的那个“因子”开始搜索，从而保证我们可以优先选择到一个“因子和”相等的多个序列中最大的那个序列，从而避免下面注释掉的那一大段代码。

不用sqrt(N)，这样会测试不通过。这也告诉我们，如果sqrt(N)不行，试着用N，反正多计算一些也无所谓。

// if (k==K && sum_==N) { // 这个条件设置的不好，这样即使k==K了，如果sum_!=N，也不会终止递归。特别的，没有搞清楚其实`k==K`才是真正的递归终点。

1. 这道题的一个坑点在于，结点数最多200个，但输入的汉密尔顿回路的结点个数，若是合法的回路，则结点数至少为201，不合法的则可能更多，如果用201的数组存储，可能越界，一些数据存储不了。

注意，即使提前就能判断不是汉密尔顿回路，也要接受剩下的输入，不然下一次循环就乱套了。

汉密尔顿回路必须：
……
6. 连接结点的边必须存在。（这个容易忽略）

// 这里有一个情况是输入的图不连通，那肯定不存在欧拉路或欧拉回路。
// 注意，单纯判断是否存在度为0的结点无法判断图是否不连通，因为可能一个图存在两个连通分量，但确实没有度为0的结点，即每个连通分量至少有两个或两个以上互连的结点。
// 判断一个图是否连通，可以用dfs次数，或用并查集查看集合个数/看头目个数。

当反复确定程序逻辑没问题，又找不出原因时，可以检查一下输出语句的格式是否符合题目要求。

visited[v] = true; // 要用visited数组记住那些已遍历过，避免走回头路。
for (int x: graph[v]) {
	if (!visited[x]) {
		path.push_back(x);
		dfs(x);
		path.pop_back();
	}
}
visited[v] = false;

